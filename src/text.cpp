//
// Created by Thomas Lienbacher on 05.01.2021.
//

#include "text.hpp"

#include <fstream>
#include <sstream>
#include <iostream>
#include "mesh.hpp"
#include "debug.hpp"

//Fonts are loaded by using files generated by using Codeheadâ€™s Bitmap Font Generator http://www.codehead.co.uk/cbfg/
Font::Font(std::string deffile, Texture *texture) : texture(texture) {
    std::ifstream in;
    in.open(deffile, std::ifstream::in);

    int img_width = 0;
    int img_height = 0;
    int start_char = 0;
    int cell_width = 0;
    int cell_height = 0;
    int global_width_offset = 0;
    int global_x_offset = 0;
    int global_y_offset = 0;
    RawCharacter raw[256];

    std::string line;
    while (std::getline(in, line)) {
        std::stringstream ss(line);

        if (line.starts_with("Image Width")) {
            ss.ignore(100, ',');
            ss >> img_width;
        }

        if (line.starts_with("Image Height")) {
            ss.ignore(100, ',');
            ss >> img_height;
        }

        if (line.starts_with("Cell Width")) {
            ss.ignore(100, ',');
            ss >> cell_width;
        }


        if (line.starts_with("Cell Height")) {
            ss.ignore(100, ',');
            ss >> cell_height;
        }

        if (line.starts_with("Start Char")) {
            ss.ignore(100, ',');
            ss >> start_char;
        }

        if (line.starts_with("Char")) {
            int charnumber = 0;
            ss.ignore(100, ' ');
            ss >> charnumber;

            if (line.find("Base Width") != std::string::npos) {
                ss.ignore(100, ',');
                int base_width = 0;
                ss >> base_width;
                raw[charnumber].base_width = base_width;
            }

            if (line.find("Width Offset") != std::string::npos) {
                ss.ignore(100, ',');
                int width_offset = 0;
                ss >> width_offset;
                raw[charnumber].width_offset = width_offset;
            }

            if (line.find("X Offset") != std::string::npos) {
                ss.ignore(100, ',');
                int x_offset = 0;
                ss >> x_offset;
                raw[charnumber].x_offset = x_offset;
            }

            if (line.find("Y Offset") != std::string::npos) {
                ss.ignore(100, ',');
                int y_offset = 0;
                ss >> y_offset;
                raw[charnumber].y_offset = y_offset;
            }
        }

        if (line.starts_with("Global Width Offset")) {
            ss.ignore(100, ',');
            ss >> global_width_offset;
        }

        if (line.starts_with("Global X Offset")) {
            ss.ignore(100, ',');
            ss >> global_x_offset;
        }

        if (line.starts_with("Global Y Offset")) {
            ss.ignore(100, ',');
            ss >> global_y_offset;
        }
    }

    int cols = img_width / cell_width;
    int rows = img_height / cell_height;

    for (int i = 0; i < 256; ++i) {
        if (i < start_char) continue;
        RawCharacter rc = raw[i];
        char c = (char) i;
        int col = (i - start_char) % cols;
        int row = (i - start_char) / rows;

        int x = col * cell_width + global_x_offset + rc.x_offset;
        int y = row * cell_height + global_y_offset + rc.y_offset;
        int width = global_width_offset + rc.base_width + rc.width_offset;
        int height = cell_height; //or font height


        auto iw = (float) img_width;
        auto ih = (float) img_height;

        BakedCharacter bc;
        bc.width = (float) width;
        bc.height = (float) height;

        bc.uvs.points.top_left.x = (float) x / iw;
        bc.uvs.points.top_left.y = 1.0f - (float) (y + height) / ih;

        bc.uvs.points.top_right.x = (float) (x + width) / iw;
        bc.uvs.points.top_right.y = 1.0f - (float) (y + height) / ih;

        bc.uvs.points.bottom_right.x = (float) (x + width) / iw;
        bc.uvs.points.bottom_right.y = 1.0f - (float) y / ih;

        bc.uvs.points.bottom_left.x = (float) x / iw;
        bc.uvs.points.bottom_left.y = 1.0f - (float) y / ih;

        chars.emplace(std::pair(c, bc));
    }

    in.close();
}

Text::Text(std::string text, Font *font) : font(font) {
    num_vertices = text.length() * 6; // two triangles with 3 each
    auto vertices = new float[num_vertices * 2];
    auto *texcoords = new float[num_vertices * 2];

    float x_advance = 0;
    for (int i = 0; i < text.length(); ++i) {
        char c = text[i];
        auto bc = font->chars.find(c)->second;

        //triangle 1
        vertices[i * 12] = x_advance;
        vertices[i * 12 + 1] = 0;

        vertices[i * 12 + 2] = x_advance + bc.width;
        vertices[i * 12 + 3] = 0;

        vertices[i * 12 + 4] = x_advance;
        vertices[i * 12 + 5] = bc.height;

        //triangle 2
        vertices[i * 12 + 6] = x_advance + bc.width;
        vertices[i * 12 + 7] = 0;

        vertices[i * 12 + 8] = x_advance + bc.width;
        vertices[i * 12 + 9] = bc.height;

        vertices[i * 12 + 10] = x_advance;
        vertices[i * 12 + 11] = bc.height;

        x_advance += bc.width;
        height = bc.height;

        auto uv = bc.uvs.points;
        //triangle 1
        texcoords[i * 12] = uv.top_left.x;
        texcoords[i * 12 + 1] = uv.top_left.y;
        texcoords[i * 12 + 2] = uv.top_right.x;
        texcoords[i * 12 + 3] = uv.top_right.y;
        texcoords[i * 12 + 4] = uv.bottom_left.x;
        texcoords[i * 12 + 5] = uv.bottom_left.y;

        //triangle 2
        texcoords[i * 12 + 6] = uv.top_right.x;
        texcoords[i * 12 + 7] = uv.top_right.y;
        texcoords[i * 12 + 8] = uv.bottom_right.x;
        texcoords[i * 12 + 9] = uv.bottom_right.y;
        texcoords[i * 12 + 10] = uv.bottom_left.x;
        texcoords[i * 12 + 11] = uv.bottom_left.y;
    }

    width = x_advance;

    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);

    glGenBuffers(2, vbos);

    const unsigned int stride = 0;
    const void *offset = nullptr;

    glBindBuffer(GL_ARRAY_BUFFER, vbos[0]);
    glBufferData(GL_ARRAY_BUFFER, num_vertices * 2 * sizeof(float), vertices, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, stride, offset);

    glBindBuffer(GL_ARRAY_BUFFER, vbos[1]);
    glBufferData(GL_ARRAY_BUFFER, num_vertices * 2 * sizeof(float), texcoords, GL_STATIC_DRAW);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, stride, offset);

    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);

    delete[] texcoords;
    delete[] vertices;
}

Text::~Text() {
    glDeleteVertexArrays(1, &vao);
    glDeleteBuffers(2, vbos);
}

void Text::render(Shader *font_shader) {
    font_shader->use();
    font->texture->bind();
    Mesh::bind(vao);
    glDrawArrays(GL_TRIANGLES, 0, num_vertices);
}

float Text::get_width() const {
    return width;
}

float Text::get_height() const {
    return height;
}
